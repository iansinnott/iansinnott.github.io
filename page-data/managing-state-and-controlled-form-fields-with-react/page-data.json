{"componentChunkName":"component---src-templates-post-js","path":"/managing-state-and-controlled-form-fields-with-react/","result":{"data":{"post":{"canonicalURL":"https://blog.iansinnott.com/managing-state-and-controlled-form-fields-with-react/","content_html":"<p><span class=\"bold\">UPDATE (2016-07-28):</span> As of React v15 <code >valueLink</code> and <code >checkedLink</code> are officially deprecated. I heavily advocate the use of both of these APIs in this article. If you want to see my thoughts on the deprecation see <a href=\"#comment%E2%B8%BB2692300179\">this comment below</a>. For the official deprecation see <a href=\"https://facebook.github.io/react/docs/two%E2%B8%BBway%E2%B8%BBbinding%E2%B8%BBhelpers.html\">the docs article here</a>.</p>\n<p>With React, you basically get two different ways to deal with forms:</p>\n<ul><li>Standard input elements that can be modified by the user</li></ul>\n<ul><li>&quot;Controlled&quot; input elements that can only be modified programatically</li></ul>\n<p>The first type is pretty straightforward in React, you simply don&#39;t provide a <code >value</code> prop:</p>\n<pre>React.createClass({\nrender (\n&lt;input type=&#39;text&#39; /&gt;\n);\n});</pre>\n<p>The value of that <code >&lt;input&gt;</code> element can be edited by the user in a browser, just like one would expect in a normal we app.</p>\n<p>The other type of input—a &quot;Controlled&quot; input—looks almost the same, but has a <code >value</code> property:</p>\n<pre>React.createClass({\nrender (\n&lt;input type=&#39;text&#39; value=&quot;You can&#39;t change me!&quot; /&gt;\n);\n});</pre>\n<p>The value of this <code >&lt;input&gt;</code> element will stubbornly refuse to change no matter what the user does. This is generally a terrible user experience, so React will actually warn you that your input cannot be modified:</p>\n<figure><img src=\"https://dropsinn.s3.amazonaws.com/Screen%20Shot%202015-05-11%20at%2011.12.36%20PM.png?table=block&id=\" alt=\"React warning message\"/><figcaption>React warning message</figcaption></figure>\n<p>If you&#39;re new-ish to React you might not know why you would want to do this. The answer is <span class=\"italic\">state</span>. React puts a big emphasis on explicitly keeping your components state in the <code >state</code> property. So in order to create a form input that responds to user input you will need to use two-way data binding. Meaning the <code >value</code> of the <code >&lt;input&gt;</code> element will flow from your component into the DOM, but also from the DOM into your component. In other words, they will be kept in sync.</p>\n<h2>Manual Two-way data binding</h2>\n<p>The most common way to accomplish two-way data binding in React is to be explicit. This is by design, and it&#39;s a good practice for smaller forms. Here&#39;s how an example:</p>\n<pre>React.createClass({\ngetInitialState() {\ninputValue: &#39;&#39;\n},\n\nrender() {\nreturn (\n&lt;input\ntype=&#39;text&#39;\nvalue={this.state.inputValue}\nonChange={this.onChange} /&gt;\n);\n},\n\nonChange(e) {\nthis.setState({ inputValue: e.target.value });\n}\n});</pre>\n<p>Here we&#39;ve bound our input&#39;s change event to the component&#39;s <code >onChange</code> function which will update <code >this.state</code>. Whenever <code >this.state</code> is updated the component will be re-rendered, causing the input value to reflect what the user typed.</p>\n<p>If that&#39;s not quite clear, I highly recommend taking a look at the <a href=\"https://facebook.github.io/react/docs/forms.html\">Forms guide on the React website</a>.</p>\n<p>The code above is explicit and not overly complicated, which is great for maintainabillty. There are virtually no downsides to this approach when dealing with a small form that only contains a few inputs. Issues only begin to crop up when you have many inputs that all need to update state.</p>\n<p>That&#39;s why we have...</p>\n<h2>The LinkedStateMixin</h2>\n<p>React comes with a handy mixin to help you achieve two-way data-binding very quickly. Use the LinkedStateMixin to save yourself soem hassle when wiring up large forms to stay in sync with component state:</p>\n<pre>// Make sure to require react with addons\nvar React = require(&#39;react/addons&#39;);\n\nReact.createClass({\nmixins: [React.addons.LinkedStateMixin],\n\ngetInitialState() {\ninputValue: &#39;&#39;\n},\n\nrender() {\nreturn (\n&lt;input type=&#39;text&#39; valueLink={this.linkState(&#39;inputValue&#39;)} /&gt;\n);\n}\n});</pre>\n<p>As you can see we replaced the <code >value</code> prop with <code >valueLink</code>. If you haven&#39;t heard of <code >valueLink</code> I&#39;ll explain it in a sec.</p>\n<p>The <code >LinkedStateMixin</code> saves us a good deal of typing, and especially when you have a large number of form fields that need to be tied to component state. The issue is that it&#39;s not very flexible. Essentially it just binds the value of an input field to <code >this.state</code>. But what if you are building a <span class=\"italic\">stateless</span> form component that gets all it&#39;s values from props? Or, more interestingly, what if you are using Flux and don&#39;t want to set state directly but rather call an action that updates a store?</p>\n<p>This is what <code >valueLink</code> is great for.</p>\n<h2>What exactly is <code >valueLink</code>?</h2>\n<p>The <code >valueLink</code> prop is a fairly under-documented feature of form inputs in React that simplifies the onChange / setState pattern described at the beginning of this post. It&#39;s a shortcut for telling an input where to get its <code >value</code> prop from and what function to call when an <code >onChange</code> event is fired. In it&#39;s most simple form the <code >valueLink</code> prop points to a plain old JS object with two distinct props:</p>\n<ul><li><code >value</code>: The value of the input at any given time</li></ul>\n<ul><li><code >requestChange</code>: The function to call whenever <code >onChange</code> is fired on the input. <code >requestChange</code> will be called with the update value of the input, so there&#39;s no need to access the value using an event object as you might do if you were using the actual <code >onChange</code> event.</li></ul>\n<p>If you&#39;re familiar with React&#39;s PropTypes feature then this expression of <code >valueLink</code> as a <code >propType</code> should make it clear what you&#39;re going for:</p>\n<pre>React.createClass({\npropTypes: {\nvalueLink: React.PropTypes.shape({\nvalue: React.PropTypes.any.isRequired,\nrequestChange: React.PropTypes.func.isRequired\n})\n}\n});</pre>\n<h2>Manually linking input value to state with <code >valueLink</code></h2>\n<p>Let&#39;s check out an example.</p>\n<pre>function makeValueLink(key) {\nreturn {\nvalue: this.state[key],\nrequestChange: function(newValue) {\nnewState = {};\nnewState[key] = newValue;\nthis.setState(newState);\n}\n}\n}\n\nReact.createClass({\ngetInitialState() {\ninputValue: &#39;&#39;\n},\n\nrender() {\nreturn (\n&lt;input type=&#39;text&#39; valueLink={makeValueLink(&#39;inputValue&#39;)} /&gt;\n);\n}\n});</pre>\n<p>Now you will get the same two-way data binding as you did when using the <code >LinkedStateMixin</code>. What we&#39;ve done here is basically created our own version of the <code >LinkedStateMixin</code> to demonstrate how <code >valueLink</code> works.</p>\n<p>You can use <code >valueLink</code> to bind the <code >value</code> prop of any input to the state of a component. If you instead want to set state on a parent component you can pass a <code >valueLink</code> down as a prop just like you would do with an <code >onChange</code> callback.</p>\n<h3>Don&#39;t forget about <code >checkedLink</code></h3>\n<p>The other important point to note is that some input types, namely <code >&lt;input type=&#39;radio&#39;&gt;</code> and <code >&lt;input type=&#39;checkbox&#39;&gt;</code> use the <code >checked</code> prop because they represent boolean values. They still use a <code >value</code> prop to determine what value corresponds to the <code >checked</code> prop, but it&#39;s only the <code >checked</code> prop that can be changed by the user.</p>\n<p>React acknowledges this and provides us with the <code >checkedLink</code> prop, which works exactly like <code >valueLink</code> except it binds the <code >checked</code> prop to state instead of the <code >value</code> prop.</p>\n<pre>function makeValueLink(key) {\nreturn {\nvalue: this.state[key],\nrequestChange: function(newValue) {\nnewState = {};\nnewState[key] = newValue;\nthis.setState(newState);\n}\n}\n}\n\nReact.createClass({\ngetInitialState() {\nbooleanValue: &#39;&#39;\n},\n\nrender() {\nreturn (\n&lt;input type=&#39;checkbox&#39; checkedLink={makeValueLink(&#39;booleanValue&#39;)} /&gt;\n);\n}\n});</pre>\n<p>Note that when using <code >checkedLink</code> the shape of the object you pass in is still exactly the same, i.e. it needs a <code >value</code> prop and a <code >requestChange</code> prop. This is good because it means we can use our <code >makeValueLink</code> function to bind any type of input to state including checkboxes and radios.</p>\n<h2>Putting it all together—Building a Flux form</h2>\n<p>The importance of <code >valueLink</code> really shines when you&#39;re using something like Flux where you don&#39;t actually want to update <code >this.state</code> directly but would like instead for data to flow through actions to stores which control the UI state. Using <code >valueLink</code> makes this is quite easy:</p>\n<pre>var AppActions = require(&#39;./AppActions&#39;);\n\nfunction makeValueLink(key) {\nreturn {\nvalue: this.state[key],\nrequestChange: function(newValue) {\nAppActions.doSomething(key, newValue);\n}\n}\n}\n\n/**\n\nThis code is written much like you would if you were using the Alt Flux\n\nimplementation. The syntax would likely be slightly different with other\n\nlibraries.\n*/\nReact.createClass({\n\n// Assuming our store (AppStore) has a getState method, we would get the\n// initial state like so\ngetInitialState() {\nreturn AppStore.getState();\n},\n\n// Listen to our store for changes\ncomponentDidMount() {\nAppStore.listen(this.onChange);\n},\n\n// Stop listening if this component is unmounted\ncomponentWillUnmount() {\nAppStore.unlisten(this.onChange);\n},\n\n// Whenever our store emits a change event, update <code >this.state</code> to reflect\n// the state of the store.\nonChange() {\nthis.setState(AppStore.getState());\n},\n\nrender() {\nreturn (\n&lt;input type=&#39;checkbox&#39; checkedLink={makeValueLink(&#39;booleanValue&#39;)} /&gt;\n);\n}\n})</pre>\n<p>Now whenever you check the checkbox <code >AppActions.doSomething</code> will be called with a <code >key</code> of <code >&#39;booleanValue&#39;</code> and a <code >newValue</code> of either <code >true</code> or <code >false</code> depending on whether or not it is checked.</p>\n<p>Then in <code >AppActions</code> you would do whatever you want with the data and most likely dispatch it to all stores so they could update their state accordingly. <code >AppStore</code> would get the dispatch and update it&#39;s internal representation of state</p>\n<p>Hope all this helps as you build forms with React.</p>","properties":{"tags":"javascript,react","created":"2015-05-11T00:00:00.000Z","title":"Managing state and controlled form fields with React","disqusId":null}}},"pageContext":{"id":"d226aa2d-35f2-5f42-b8d2-d9fb93ed7c7a","prev":{"id":"a0a78b43-83a7-5634-b466-061b69244ff4","slug":"in-search-of-the-ultimate-tooling-workflow","properties":{"title":"In search of the ultimate tooling workflow","created":"2015-05-03T00:00:00.000Z"}}}}}