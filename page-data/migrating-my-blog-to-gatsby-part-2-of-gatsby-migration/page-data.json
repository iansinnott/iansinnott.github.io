{"componentChunkName":"component---src-templates-post-js","path":"/migrating-my-blog-to-gatsby-part-2-of-gatsby-migration/","result":{"data":{"post":{"canonicalURL":"https://blog.iansinnott.com/migrating-my-blog-to-gatsby-part-2-of-gatsby-migration/","content_html":"\n<h1>Migrating a blog to Gatsby</h1>\n<p><span class=\"bold\">NOTE:</span> This is part 2 of my Gatsby migration series. You can find part 1 here: <a href=\"http://blog.iansinnott.com/migrating-to-gatsbyjs-part-1/\">Migrating to GatsbyJS Part 1</a>.</p>\n<p><span class=\"bold\">Abstract:</span> Gatsby is a great tool for building a blog. In part 1 I did the more simple task of migrating an existing React site to Gatsby. This time I migrated my blog, which was a lot more involved and required a lot more Gatsby-specific knowledge.</p>\n<p>Here&#39;s the gist of what I&#39;m going to cover:</p>\n<ul><li>Preparing an existing blog for migration</li></ul>\n<ul><li>Configuring Gatsby to handle markdown</li></ul>\n<ul><li>Querying your markdown files using GraphQL</li></ul>\n<ul><li>Adding custom data to the generated GraphQL schema</li></ul>\n<ul><li>Turning all your markdown files into static pages</li></ul>\n<p>Let&#39;s jump in.</p>\n<h2>Preparing your existing blog for migration</h2>\n<p><span class=\"bold\">NOTE:</span> If you don&#39;t already have a blog or want to create one from scratch there&#39;s a <a href=\"https://www.gatsbyjs.org/blog/2017-07-19-creating-a-blog-with-gatsby/\">tutorial for exactly that on Gatsby&#39;s website</a>.</p>\n<p>Let&#39;s move some files around. Gatsby gives you a good amount of flexibility when it comes to file structure, but for consistency with the docs I&#39;m going to use their suggested file structure for migrating my blog. How you handle this step will depend on what you&#39;re migrating from. I am migrating form Hexo, which is very similar to Jekyll in how it structures files.</p>\n<h3>Clean up your source repo</h3>\n<p>For the first step, clear everything other than your actual post content out of the repo. For me, this meant everything that wasn&#39;t under the <code >source/</code> directory (that&#39;s a Hexo convention). One way to do this is to take everything not relevant to the upcoming Gatsby blog and move it into its own directory that doesn&#39;t interfere with anything. I chose to create <code >hexo.bak/</code> where all my old blog files would live (except for the content).</p>\n<p>You could also simply delete everything other than your raw content. It&#39;s up to you. But once your done with this cleanup you should have made a decision on where to hold your content, and moved everything else away or removed it.</p>\n<p>Here&#39;s what that looks like for me:</p>\n<pre>.\n‚îú‚îÄ‚îÄ content\n‚îÇ   ‚îú‚îÄ‚îÄ _drafts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [ Draft markdown files ... ]\n‚îÇ   ‚îî‚îÄ‚îÄ _posts\n‚îÇ       ‚îî‚îÄ‚îÄ [ Post markdown files ... ]\n‚îî‚îÄ‚îÄ hexo.bak\n    ‚îî‚îÄ‚îÄ [ All my old hexo related files ... ]\n</pre>\n<p>For the rest of this post I&#39;ll ignore the <code >hexo.bak/</code> directory because it&#39;s not relevant to Gatsby.</p>\n<h2>Set up Gatsby</h2>\n<p>You need to copy all the standard Gatsby boilerplate into your directory. There are many ways you could do this but I&#39;ll go over what I did.</p>\n<p>To get all the Gatsby files you can use the Gatsby CLI.</p>\n<pre>npm install -g gatsby-cli   # Install gatsby CLI\ngatsby new temp-gatsby-files # Initialize gatsby in a temp directory\ncp -R temp-gatsby-files/* ./ # Copy all the files into your root directory\nrm -rf temp-gatsby-files     # Remove the temp directory\n</pre>\n<p>However you get Gatsby initialized in your repository root, afterwards you should have a file structure that looks something like this:</p>\n<pre>.\n‚îú‚îÄ‚îÄ content\n‚îÇ   ‚îî‚îÄ‚îÄ [ Markdown files ... ]\n‚îú‚îÄ‚îÄ public\n‚îÇ   ‚îî‚îÄ‚îÄ index.html\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ layouts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.css\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js\n‚îÇ   ‚îî‚îÄ‚îÄ pages\n‚îÇ       ‚îú‚îÄ‚îÄ 404.js\n‚îÇ       ‚îú‚îÄ‚îÄ index.js\n‚îÇ       ‚îî‚îÄ‚îÄ page-2.js\n‚îú‚îÄ‚îÄ gatsby-config.js\n‚îî‚îÄ‚îÄ package.json\n</pre>\n<p>Now run the Gatsby dev server to make sure everything works:</p>\n<pre>npm run develop</pre>\n<p><span class=\"bold\">NOTE:</span> If you open up <code >package.json</code> you can see what the <code >develop</code> script is doing.</p>\n<p>Boom üí•! The default site is up.</p>\n<img src=\"https://dropsinn.s3.amazonaws.com/Screen%20Shot%202017-08-26%20at%2012.57.40%20PM.png?table=block&id=\" />\n<h2>Rendering a list of posts</h2>\n<p>Let&#39;s customize that landing page to render a list of posts. You will also probably want to customize the header and overall layout.</p>\n<h3>Customizing the layout</h3>\n<p>This is pretty simple. Just modify the primary layout file that was generated:</p>\n<pre>src/layouts/index.js\n</pre>\n<p>You can also customize the styles in <code >src/layouts/index.css</code>. Stylus, Sass, Less, etc are also supported if you add the appropriate plugin. <a href=\"https://github.com/gatsbyjs/gatsby/tree/master/packages\">Here&#39;s the list</a> (there&#39;s a page on the website too, but the source is more up to date).</p>\n<p><span class=\"bold\">Sidenote:</span> You can also create your own plugin to do whatever you want, which I talked about in part 1.</p>\n<h3>Customizing the landing page</h3>\n<p>Also straightforward, just edit:</p>\n<pre>src/pages/index.js\n</pre>\n<p>This file is where we&#39;ll actually render out the list of posts. So where the hell does that data come from??</p>\n<h3>Querying data with GraphQL</h3>\n<p>Now we&#39;re getting in to the meat of Gatsby and one of the areas where it really shines: Data sources. You can pull in data from anywhere to be rendered in your blog, but for our use case the only data source will be the file system (aka the markdown files stored on your hard drive).</p>\n<p>But first, let&#39;s check out <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>. It&#39;s an excellent playground for testing out GraphQL queries in any GraphQL project. Gatsby ships with it enabled by default, thank goodness. GraphQL can actually be oddly opaque without this excellent tool.</p>\n<p>Visit <a href=\"http://localhost:8000/___graphql\">http://localhost:8000/___graphql</a> in the browser and you&#39;ll be greeted with this lovely dev tool:</p>\n<img src=\"https://dropsinn.s3.amazonaws.com/Screen%20Shot%202017-08-26%20at%201.31.08%20PM.png?table=block&id=\" />\n<p>I recommend getting to know this tool if you&#39;re not already familiar. You will be coming back to this often to find the right query to pull data for your pages.</p>\n<h3>Querying the file system</h3>\n<p>If you play around with GraphiQL you&#39;ll notice there&#39;s not that much there. Let&#39;s fix that. We need to teach Gatsby how to query the file system. Luckily this is so common it&#39;s been done for you. Install the file system source plugin:</p>\n<pre>yarn add gatsby-source-filesystem\n</pre>\n<p>Now modify <code >gatsby-config.js</code> to both use the plugin and tell it what directory to source files from. Add this to the <code >plugins</code> array:</p>\n<pre>{\n  resolve: &#39;gatsby-source-filesystem&#39;,\n  options: {\n    name: &#39;posts&#39;, // Name this source\n    path: path.resolve(&#39;./content/_posts&#39;), // Tell it where to find the files\n  },\n}\n</pre>\n<p>As you can see on my system I keep all my markdown files under <code >content/_posts/</code> which is reflected in the <code >path</code> option for the plugin.</p>\n<p>Now restart the dev server and open GraphiQL up again. You should have access to the <code >allFile</code> root type. Try running this query:</p>\n<pre>query {\n  allFile {\n    edges {\n      node {\n        ext\n        name\n      }\n    }\n  }\n}\n</pre>\n<p>This will list all the files in the directory you specified to the plugin. You can query all sorts of information about the files. Just investigate the fields available to you under <code >node</code> in GraphQL.</p>\n<p><span class=\"bold\">Pro tip:</span> Hit &lt;kbd&gt;ctrl&lt;/kbd&gt;&lt;kbd&gt;space&lt;/kbd&gt; to trigger autocomplete and bring up the list of all available fields.</p>\n<h3>Handling Markdown</h3>\n<p>Being able to query files is a big win, and if you have a directory of HTML files this is all you will need. But if you want to render markdown files as HTML you will need another plugin. Let&#39;s add that now:</p>\n<pre>yarn add gatsby-transformer-remark\n</pre>\n<p>As before, add it to the <code >plugins</code> field in <code >gatsby-config.js</code>:</p>\n<pre>{\n  resolve: &#39;gatsby-transformer-remark&#39;,\n  options: {\n    plugins: [],\n  },\n}\n</pre>\n<p>This particular plugin can also take <span class=\"italic\">its own</span> plugins via the <code >plugins</code> option. I&#39;ve left it empty but this is where you can add things like syntax highlighting or auto-linking of headers. Here&#39;s the current list: <a href=\"https://www.npmjs.com/search?q=gatsby-remark\">https://www.npmjs.com/search?q=gatsby-remark</a></p>\n<p>Save and restart your dev server, then go into GraphiQL and try out the new <code >allMarkdownRemark</code> field:</p>\n<pre>query {\n  allMarkdownRemark {\n    edges {\n      node {\n        html\n      }\n    }\n  }\n}\n</pre>\n<p>This query gives you the full HTML for all your markdown files. If you are using frontmatter you can also access that here. I&#39;m assuming you have a <code >title</code> field in your frontmatter:</p>\n<pre>query {\n  allMarkdownRemark {\n    edges {\n      node {\n        frontmatter {\n          title\n        }\n        html\n      }\n    }\n  }\n}\n</pre>\n<p>Now you have access to the full HTML of your posts as well as the titles. With this we have enough information to render a list of posts on the front page.</p>\n<h3>Getting GraphQL data into your components</h3>\n<p>Gatsby has the concept of the <code >pageQuery</code>. For every page you create you can specify a <code >pageQuery</code> that will pass data into the default export of that page.</p>\n<pre>// src/pages/index.js\nimport React from &#39;react&#39;;\n\nexport default class BlogIndex extends React.Component {\n  render() {\n    // Handle graphql errors\n    if (this.props.errors &amp;&amp; this.props.errors.length) {\n      this.props.errors.forEach(({ message }) =&gt; {\n        console.error(`BlogIndex render errr: ${message}`);\n      });\n      return &lt;h1&gt;Errors found: Check the console for details&lt;/h1&gt;;\n    }\n\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;Some things I wrote&lt;/h2&gt;\n        {this.props.data.allMarkdownRemark.edges.map(({ node }, i) =&gt; (\n          &lt;a key={i}&gt;{node.frontmatter.title}&lt;/a&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport const pageQuery = graphql`\n  query {\n    allMarkdownRemark {\n      edges {\n        node {\n          frontmatter { title }\n        }\n      }\n    }\n  }\n`;\n</pre>\n<p>This is a simplified example, but there are a few things going on that might not be intuitive.</p>\n<ul><li>In the render method we first check for errors, and return early if any are found</li></ul>\n<ul><li>If no error are found we render a link for each item in the array: <code >this.props.data.allMarkdownRemark.edges</code></li></ul>\n<ul><li>We export a <code >pageQuery</code> variable that is constructed using the magic <code >graphql</code> global</li></ul>\n<p>The error handling is pretty straightforward, if a bit verbose, as long as you know what graphql responses look like. In case you didn&#39;t know, if you get an error in a graphql query the response will contain the <code >errors</code> array. We check for this array and handle it accordingly.</p>\n<p>Now let&#39;s looks specifically at where we render a link for each blog post:</p>\n<pre>{this.props.data.allMarkdownRemark.edges.map(({ node }, i) =&gt; (\n  &lt;a key={i}&gt;{node.frontmatter.title}&lt;/a&gt;\n))}\n</pre>\n<p>Notice that the data shape is exactly what we specified in the GraphQL query. This may seem like a lot of nesting just to get at an array of data, but GraphQL emphasizes <span class=\"italic\">clarity</span> over conciseness. You&#39;ll notice that if you run your GraphQL query in GraphiQL the data will have the exact shape described above.</p>\n<p>And that brings us finally to the page query:</p>\n<pre>export const pageQuery = graphql`\n  query {\n    allMarkdownRemark {\n      edges {\n        node {\n          frontmatter { title }\n        }\n      }\n    }\n  }\n`;\n</pre>\n<p>This is how you get data from Gatsby into your react components. Make sure you don&#39;t misspell <code >pageQuery</code> otherwise you won&#39;t get what you want.</p>\n<p>Also note that <code >graphql</code> is just some magic global variable. Your linter will probably complain about it being undefined and you will just have to ignore it. Personally I think it would be more clear if <code >graphql</code> was imported from Gatsby, but the project is still young so the API could change at some point ¬Ø\\\\\\<span class=\"italic\">(„ÉÑ)\\</span>/¬Ø</p>\n<h3>Linking to blog posts</h3>\n<blockquote>But the links don&#39;t link anywhere... where&#39;s that href?</blockquote>\n<p>Let&#39;s remedy that. Import the <code >gatsby-link</code> component and swap it for the simple <code >&lt;a&gt;</code> tag that was in there before:</p>\n<pre>import React from &#39;react&#39;;\nimport Link from &#39;gatsby-link&#39;;\n\nexport default class BlogIndex extends React.Component {\n  render() {\n    // Handle graphql errors\n    if (this.props.errors &amp;&amp; this.props.errors.length) {\n      this.props.errors.forEach(({ message }) =&gt; {\n        console.error(`BlogIndex render errr: ${message}`);\n      });\n      return &lt;h1&gt;Errors found: Check the console for details&lt;/h1&gt;;\n    }\n\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;Some things I wrote&lt;/h2&gt;\n        {this.props.data.allMarkdownRemark.edges.map(({ node }, i) =&gt; (\n          &lt;Link to={/* ??? */} key={i}&gt;{node.frontmatter.title}&lt;/Link&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n</pre>\n<blockquote>But what does it link to? What is the URL of each blog post?</blockquote>\n<p>That&#39;s an open question because it depends on your data and how you structured it before. For example, if you included the intended URL in the frontmatter of each post it&#39;s a simple matter of updating your query to include that:</p>\n<pre>export const pageQuery = graphql`\n  query {\n    allMarkdownRemark {\n      edges {\n        node {\n          frontmatter {\n            title\n            url # &lt;-------------  New!\n          }\n        }\n      }\n    }\n  }\n`;\n</pre>\n<pre>{this.props.data.allMarkdownRemark.edges.map(({ node }, i) =&gt; (\n  &lt;Link to={node.frontmatter.url} key={i}&gt;{node.frontmatter.title}&lt;/Link&gt;\n))}\n</pre>\n<p>Many existing Gatsby examples use <code >path</code> within each markdown file&#39;s frontmatter to designate the url. For example:</p>\n<pre>---\ntitle: My Post\npath: my-post\n---\n\n# My post\n</pre>\n<p>In this case <code >node.frontmatter.path</code> would be used to construct URLs. If this is the case for you then you&#39;re probably all set for the index page.</p>\n<blockquote>But what if the URL for each post is NOT in the frontmatter?</blockquote>\n<p>This was exactly my situation. The URL was actually derived from the title of the post so I had to figure out how to augment the GraphQL fields with my own data. Namely the URL of the post derived from the post title.</p>\n<h2>Adding custom data to the GraphQL schema</h2>\n<p>If I have a post named &quot;Isn&#39;t this a fun title&quot; then I want the URL to be &quot;isnt-this-a-fun-title&quot;. Notice that spaces turn into hyphens and special characters are removed. This is simple enough to do in JavaScript, but it felt wrong to do it on the fly when rendering components. This is <span class=\"italic\">data</span> so I wanted to be able to query it through GraphQL.</p>\n<p>Enter <code >setFieldsOnGraphQLNodeType</code>.</p>\n<p><span class=\"bold\">Aside:</span> Gatsby is super extensible. It&#39;s the primary reason I switched from Hexo which worked well enough for my use case.</p>\n<p>In order to extend this particular part of Gatsby you need to create a <code >gatsby-node.js</code> file. This file let&#39;s you work with all of Gatsby&#39;s plugin hooks that are run in node. The GraphQL server is run in node, so this is where we add custom fields. Example:</p>\n<pre>// gatsby-node.js\nconst { GraphQLString } = require(&#39;graphql&#39;);\n\nconst getURL = (node) =&gt; {\n  /* See the source link below for implementation */\n};\n\nexports.setFieldsOnGraphQLNodeType = ({ type }) =&gt; {\n  if (type.name !== &#39;MarkdownRemark&#39;) {\n    return {};\n  }\n\n  return Promise.resolve({\n    url: {\n      type: GraphQLString,\n      resolve: node =&gt; getURL(node),\n    },\n  });\n};\n</pre>\n<blockquote>Source code for gatsby-node.js here.</blockquote>\n<p>If you&#39;ve worked with GraphQL before this should look very familiar. In fact, as you can see the string type is imported directly from GraphQL and not from Gatsby.</p>\n<p>Basically you check the type of node and if it&#39;s a type your interested in you resolve with some fields. Fields in GraphQL require a <code >type</code> and a way to <code >resolve</code> the value.</p>\n<p>I&#39;ve omitted the implementation of <code >getURL</code> here, but you can see the <a href=\"https://github.com/iansinnott/iansinnott.github.io/blob/gatsby-migration/gatsby-node.js#L17\">source code here</a> (NOTE: in the source it&#39;s called <code >getSlug</code> instead of <code >getURL</code>).</p>\n<p>You can use this technique to add any field you want to your GraphQL schema. Now you should be all set to render <code >Link</code> components that actually point somewhere interesting üëç.</p>\n<h2>Generating pages from markdown files</h2>\n<p>This is where it all comes together. If you finished the last section you would have ended up with a bunch of links that point to the correct URL but when you tried visiting the URL there was nothing there üòï. This is because Gatsby hasn&#39;t yet generated an additional pages. It&#39;s still just rendering whatever is in your <code >src/pages/</code> directory.</p>\n<p>By default, Gatsby will create a static HTML page for everything under <code >src/pages/</code>. At this point we&#39;ve discussed <code >src/pages/index.js</code> extensively. It will be the <code >index.html</code> page of your site, and thus your landing page.</p>\n<p>For any stand-alone pages, simply create a corresponding js file in the <code >pages/</code> directory and you are good to go. For example, <code >src/pages/about.js</code> would generate an <code >about.html</code> page. Simple.</p>\n<p>But almost everyone will want to generate some pages based on data, not on the files in the pages directory. Gatsby let&#39;s us do this.</p>\n<h3>Generating custom pages</h3>\n<p>The key here is again to hook in to one of Gatsby&#39;s many plugin hooks. In this case, <code >createPages</code>. In the same <code >gatsby-node.js</code> file as before:</p>\n<pre>// gatsby-node.js\n\n// .. other stuff from before...\n\nexports.createPages = ({ boundActionCreators }) =&gt; {\n  const { createPage } = boundActionCreators;\n  const postTemplate = path.resolve(&#39;./src/templates/custom-page.js&#39;);\n\n  // Create a custom page!\n  createPage({\n    path: `/my-custom-page/`,\n    component: postTemplate,\n    context: {} // Context will be passed in to the page query as graphql variables\n  });\n};\n</pre>\n<p>At the most basic level this method of page creation is quite simple: Grab the <code >createPage</code> function from the API and call it with some props.</p>\n<ul><li><code >path</code> is required. This is the path that your page will have as a generated HTML file. It&#39;s the URL of your final page.</li></ul>\n<ul><li><code >component</code> is also required. It&#39;s the file containing the react component that will be used to render this particular page.</li></ul>\n<ul><li><code >context</code> is optional but I&#39;ve included it here because it will be important soon. This lets you pass data down to the react component specified in the <code >component</code> option as well as the <code >pageQuery</code> (if any).</li></ul>\n<p>The API is actually pretty simple: To generate a new page call <code >createPage</code> with some props. So in pseudo code:</p>\n<pre>// Get all markdown files\n// Call create page for each one\nmarkdownFiles.forEach(post =&gt; {\n  createPage({\n    path: post.url,\n    component: &#39;./src/templates/post.js&#39;,\n    context: {\n      id: post.id,\n    },\n  });\n});\n</pre>\n<p>I&#39;ve included the pseudo code to highlight the fact that nothing too magical is going on here. We just need to call create page for every post we want to create. The implementation is a bit more verbose, but that&#39;s still all it&#39;s doing.</p>\n<p>So in order to make this work we also need to be able to query GraphQL just like we do in the page query. Gatsby let&#39;s us do exactly that by giving us access to the <code >graphql</code> object and letting us return a promise so that we can do async work.</p>\n<pre>\n// NOTE: I&#39;m using async/await to simplify the code since it&#39;s now natively supported\n// in Node 8.x. This means that our function will return a promise\nexports.createPages = async ({ graphql, boundActionCreators }) =&gt; {\n  const { createPage } = boundActionCreators;\n  const postTemplate = path.resolve(&#39;./src/templates/post.js&#39;);\n\n  // Using async await. Query will likely be very similar to your pageQuery in index.js\n  const result = await graphql(`\n    query {\n      allMarkdownRemark {\n        edges {\n          node { id url }\n        }\n      }\n    }\n  `);\n\n  if (result.errors) {\n    console.log(result.errors);\n    throw new Error(&#39;Things broke, see console output above&#39;);\n  }\n\n  // Create blog posts pages.\n  result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {\n    createPage({\n      path: node.url,\n      component: postTemplate,\n      context: { // Context will be passed in to the page query as graphql vars\n        id: node.id,\n      },\n    });\n  });\n};\n</pre>\n<p>Notice that the query is very similar to the <code >pageQuery</code> in index.js but it&#39;s not identical. This time we actually want the <code >id</code> because it will allow the post template to use the ID to query one single blog post.</p>\n<h2>Rendering individual posts</h2>\n<p>If you&#39;ve made it to this point rendering individual posts is quite straightforward. You need to:</p>\n<ul><li>Create the <code >postTemplate</code> file referenced in <code >createPages</code> above</li></ul>\n<ul><li>Export your template component as the default export</li></ul>\n<ul><li>Add a <code >pageQuery</code> that will fetch the blog post to render</li></ul>\n<p>Here it is in all it&#39;s glory:</p>\n<pre>// src/templates/post.js\nimport React from &#39;react&#39;;\n\nexport default class BlogPost extends React.Component {\n  render() {\n    const post = this.props.data.markdownRemark;\n\n    return (\n      &lt;div className=&#39;Post&#39;&gt;\n        &lt;h1&gt;{post.frontmatter.title}&lt;/h1&gt;\n        &lt;div dangerouslySetInnerHTML={{ __html: post.html }} className=&#39;content&#39; /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\n// NOTE: The $id var is passed in via context when calling createPage in gatsby-node.js\nexport const pageQuery = graphql`\n  query PostById($id: String!) {\n  \tmarkdownRemark(id: { eq: $id }) {\n      frontmatter {\n        title\n      }\n      html\n  \t}\n  }\n`;\n</pre>\n<p>If you&#39;re not used to GraphQL syntax the <code >pageQuery</code> might be a little intimidating, but it&#39;s all standard GraphQL so if you take the time to learn GraphQL on its own you will be able to use that knowledge here. I.e. it is not Gatsby-specific.</p>\n<p>The important thing to note here is that <code >$id</code> is passed in via <code >context</code> in <code >gatsby-node.js</code>. That&#39;s how the post data and processed HTML string make their way into props. Then it&#39;s just a matter of rendering as you would with any other component.</p>\n<h2>Where to go from here</h2>\n<p>There&#39;s a lot more you can do with Gatsby and it&#39;s not always obvious how to proceed, but you have the full power of JavaScript at your disposal. So as long as you don&#39;t mind reading a bit of source code to figure out how something works there&#39;s no limit to what you can implement.</p>\n<p>Here are some ideas:</p>\n<ul><li>Add previous and next buttons to each post</li></ul>\n<ul><li>Create a remark plugin to add custom block types</li></ul>\n<ul><li>Aggregate tags from your frontmatter and generate pages for all posts of a specific tag</li></ul>\n<p>Some of these‚Äîsuch as pagination‚Äîare implemented on my blog (the one your reading right now). You can find the source code here:</p>\n<p><a href=\"https://github.com/iansinnott/iansinnott.github.io/tree/gatsby-migration\">Source code for the blog</a></p>\n<h2>Closing thoughts</h2>\n<p>In my opinion Gatsby provides a few killer features:</p>\n<ul><li>Extensible through a powerful plugin API.</li></ul>\n<ul><li>Supports arbitrary data sources that can be easily queried using GraphQL.</li></ul>\n<ul><li>Splits your code automatically so you don&#39;t have to worry about bundle size increasing as a function of the number of pages you render.</li></ul>\n<p>It&#39;s not a perfect project (looking at you global <code >graphql</code> object) and it&#39;s still under heavy development, so you may run in to bugs, but in my view the pros heavily outweigh the cons. It&#39;s a best-in-class static site generator and well worth the adoption time if you want to customize your blog.</p>\n<p>If anything was unclear or you have more questions feel free to ask me on <a href=\"https://twitter.com/ian_sinn\">Twitter</a>.</p>","properties":{"tags":"javascript,react,webpack,gatsby,blog","created":"2017-08-21T00:00:00.000Z","title":"Migrating my blog to Gatsby (Part 2 of Gatsby migration)","disqusId":null}}},"pageContext":{"id":"8ec90c86-c7b6-5e17-8d25-526457725ab4","prev":{"id":"4ae1f4e3-baa7-5789-8558-e421048f71e9","slug":"migrating-to-gatsbyjs-part-1","properties":{"title":"Migrating to GatsbyJS Part 1","created":"2017-07-09T00:00:00.000Z"}}}}}