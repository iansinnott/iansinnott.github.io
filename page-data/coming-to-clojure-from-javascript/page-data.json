{"componentChunkName":"component---src-templates-post-js","path":"/coming-to-clojure-from-javascript/","result":{"data":{"post":{"canonicalURL":"https://blog.iansinnott.com/coming-to-clojure-from-javascript/","content_html":"<p>Clojure and JavaScript have a surprising amount in common. I&#39;ve been pleasantly surprised that a lot of what I know already coming from the JS world applies in Clojure too.</p>\n<h2>Functional Programming</h2>\n<p>JS is a very flexible language in that it does not enforce any particular ideology. In particular it gives you both classes and first-class functions, which means out of the box you can write your programs in an extremely object-oriented way or  an extremely functional way. </p>\n<p>I was never indoctrinated into the Cult of OOP so naturally I&#39;ve tended to write most of my code in a functional style. For example, in JS:</p>\n<pre>// First I need to define a few things that are included \n// in Clojure but not in JS\n\n// comp is short for &quot;compose&quot;. It combines functions\n// from right to left\nconst comp = (...fns) =&gt; \n\tfns.reduce((f, g) =&gt; (...args) =&gt; f(g(..args)));\n\n// str converts its args to strings and joins them\nconst str = (...args) =&gt; \n\targs.map(String).join(&quot;&quot;);\n\n// inc, short for &quot;increment&quot;, will increment an integer \nconst inc = (x) =&gt; \n\tx + 1;\n\n// Now combine some functions to make a new one. Note\n// that the functions will be composed starting at the\n// bottom. So the multiplication comes first.\nconst func = compose(\n\tstr, \n\tinc, \n\tx =&gt; x * 100);\n\nfunc(1); // =&gt; &quot;101&quot;</pre>\n<p>In Clojure:</p>\n<pre>; This code may appear much more concise than the \n; JS code, but that&#39;s largely because clojure includes\n; the functions we need out of the box\n(def func (comp \n\tstr\n\tinc\n\t#(* % 100)))\n\n(func 1) ; =&gt; &quot;101&quot;</pre>\n<p><span class=\"bold\">So similar!</span></p>\n<p>If you&#39;re not used to functional program this may all look like gibberish, however, coming from a background of using functional programming in JS clojure feels oddly familiar. </p>\n<h2>Destructuring and &quot;rest&quot; parameters</h2>\n<p>In JS and in Clojure we can extract values from collections in a structural way. I imagine that this syntax is foreign to anyone coming from a language that doesn&#39;t have it, but if you&#39;re familiar with it then you&#39;ll be quick to start using it in Clojure too.</p>\n<p>JS:</p>\n<pre>const arr = [1, 2, 3, 4, 5];\nconst [a, b, ...remaining] = arr;\nconsole.log(a, b, remaining); // =&gt; 1 2 [3, 4, 5]</pre>\n<p>Clojure:</p>\n<pre>(def arr [1 2 3 4 5])\n(let [[a b &amp; remaining] arr]\n\t(println a b remaining)) ; =&gt; 1 2 (3 4 5)</pre>\n<p>There are of course some differences here, but the two parts to focus on are:</p>\n<ul><li><code >[a, b, ...remaining] = arr</code></li></ul>\n<ul><li><code >[a b &amp; remaining] arr</code></li></ul>\n<p>See the similarity? To make it ever more explicit we can use commas (<code >,</code>) in the Clojure example: <code >[a, b, &amp; remaining] arr</code>. Commas are considered whitespace in Clojure.</p>\n<p>The key differences to notice are:</p>\n<ul><li>The use of <code >...</code> in javascript vs <code >&amp;</code> in clojure.</li></ul>\n<ul><li>JS uses the <code >=</code> symbol for assignment, whereas the <code >let</code> construct in clojure simply uses a space.</li></ul>\n<h2>Immutable Data (What?!)</h2>\n<p>This one is a bit subjective since JS does <span class=\"bold\">NOT</span> force you to use immutable data, however it is possible and is even necessary in certain architectures. Namely, lots of front-end programming over the past years has made use of immutable data.</p>\n<p>If you&#39;re worked with React and especially if you&#39;re worked with Redux then you&#39;ve used immutable data before, even if it&#39;s taken the form of manually returning new objects or arrays.</p>\n<p>Example:</p>\n<pre>const incCountState = (state) =&gt; ({\n\tcount: state.count + 1, \n\t...state \n});</pre>\n<p>In this example we <span class=\"italic\">manually</span> create a new object using the spread operator on state, thus our new state is a different object from the old state which has not mutated.</p>\n<p>Example 2, for anyone who&#39;s ever used Immutable.js:</p>\n<pre>// Here we assume state is an Immutable.Map\nconst incCountState = (state) =&gt; state.set(&quot;count&quot;, state.get(&quot;count&quot;) + 1);</pre>\n<p>As the name implies, Immutable.js is very similar to Clojure&#39;s data structures. It does not allow you to mutate anything except very explicitly.</p>","properties":{"tags":"development,javascript,clojure","created":"2020-08-11T00:00:00.000Z","title":"Coming To Clojure from JavaScript","disqusId":null}}},"pageContext":{"id":"f36c4c63-d94a-5d29-a3f8-f5a1a3c723b0","prev":{"id":"fa801eaa-74f2-5ed0-b2c6-e6462967c7aa","slug":"how-to-disable-live-reload-in-create-react-app","properties":{"title":"How to Disable Live Reload in create-react-app","created":"2020-08-08T00:00:00.000Z"}}}}}