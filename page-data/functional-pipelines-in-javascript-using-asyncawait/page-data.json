{"componentChunkName":"component---src-templates-post-js","path":"/functional-pipelines-in-javascript-using-asyncawait/","result":{"data":{"post":{"canonicalURL":"https://blog.iansinnott.com/functional-pipelines-in-javascript-using-asyncawait/","content_html":"<p>Did you know that <code >async</code>/<code >await</code> syntax is great for <span class=\"italic\">synchronous</span> operations too? Really.</p>\n<p>Let&#39;s say you want to perform some operations on a string:</p>\n<pre>let input = &quot; some user input &lt;script&gt;alert(&#39;pwnd!&#39;);&lt;/script&gt;&quot;;\ninput = input.trim();\ninput = sanitizeHTML(input);\ninput = `You submitted &lt;pre&gt;${input}&lt;/pre&gt;`; \ndisplay(input);</pre>\n<p>This example is a bit contrived, but bear with me. The point here is that there are a number of self-contained operations we want to perform on our input string <code >input</code>.</p>\n<h1>How could we improve this?</h1>\n<p>There&#39;s nothing wrong with the above example, however, reassigning a variable just doesn&#39;t feel quite right... what we have here is a functional pipeline, so it would be ideal to be able to model our code as a functional pipeline as well.</p>\n<h3>Manual Functional Composition</h3>\n<p>One way we could change this code is to add a <code >pipe</code> function that will let us actually create a functional pipeline.</p>\n<pre>const pipe = (...fns) =&gt; fns.reduce((f, g) =&gt; (x) =&gt; g(f(x)));\n\n// Build up a functional pipeline\nconst fn = pipe(\n  x =&gt; x.trim(),\n\tx =&gt; sanitizeHTML(x),\n\tx =&gt; `You submitted &lt;pre&gt;${input}&lt;/pre&gt;`,\n  x =&gt; display(x),\n);\n\nlet input = &quot; some user input &lt;script&gt;alert(&#39;pwnd!&#39;);&lt;/script&gt;&quot;;\nfn(input); // Run it</pre>\n<p>This is a valid approach and one I&#39;ve used in the past many times. However, it has some drawbacks:</p>\n<ol><li>This type of code is often opaque to new programmers or programmers without any background in functional programming.</li></ol>\n<ol><li>For synchronous operations it requires building up a function even if you really just want to run a series of functions immediately and use the result.</li></ol>\n<ol><li>For <span class=\"italic\">async</span> operations we can still use the approach above but may become harder to reason about and it will almost certainly exacerbate the first caveat, becoming less readable to outsiders.</li></ol>\n<h2>Promises can help</h2>\n<p>Now let&#39;s rewrite this functionality using promises.</p>\n<pre>const main = async (input) =&gt; {\n  const x = await Promise.resolve(input)\n\t\t.then(x =&gt; x.trim())\n    .then(x =&gt; sanitizeHTML(x))\n\t\t.then(x =&gt; `You submitted &lt;pre&gt;${input}&lt;/pre&gt;`)\n\t\n  display(x);\n};\n\nmain().then(() =&gt; console.log(&#39;Complete.&#39;));</pre>\n<p>Look at that, all our operations neatly pipeline without any external libraries. What&#39;s more, we can now handle async operations and sync operations together in the same way.</p>\n<p>Let&#39;s assume <code >display</code> is an async operations. In the above example we could simply add an <code >await</code> in front of it and our function would continue working as normally. Or we could include it in the pipeline:</p>\n<pre>Promise.resolve(input)\n\t\t.then(x =&gt; x.trim())\n    .then(x =&gt; sanitizeHTML(x))\n\t\t.then(x =&gt; `You submitted &lt;pre&gt;${input}&lt;/pre&gt;`)\n    .then(x =&gt; display(x)) // Even if display is async this will work </pre>\n<h1>The point</h1>\n<p>Promises are pretty flexible, and can be used to model both sync and async operations without any external library code.</p>","properties":{"tags":null,"created":"2020-09-19T00:00:00.000Z","title":"Functional Pipelines in JavaScript Using async/await","disqusId":null}}},"pageContext":{"id":"e411aff0-6f25-5b72-b0e4-13f9e86dbade","prev":{"id":"d8a9efd2-763c-587f-993a-d94649f521ba","slug":"what-is-going-on-with-quoras-ui","properties":{"title":"What is going on with Quora's UI?","created":"2020-09-07T00:00:00.000Z"}}}}}