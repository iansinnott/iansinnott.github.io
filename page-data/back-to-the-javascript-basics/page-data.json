{"componentChunkName":"component---src-templates-post-js","path":"/back-to-the-javascript-basics/","result":{"data":{"post":{"canonicalURL":"https://blog.iansinnott.com/back-to-the-javascript-basics/","content_html":"<p>Today I was interviewed for a developer position at a San Francisco startup and I was caught off guard when I was asked to create a simple implementation of &quot;inheritance&quot; in JS. Inheritance is in quotes because, well, this is JS we&#39;re talking about. There is no real inheritance in the classical sense, but we can certainly make it work. The interview question went something like this:</p>\n<blockquote>Create a class Animal with a <code >walk</code> method. Then create a class Dog that inherits from Animal.</blockquote>\n<p>Simple enough, right? Here&#39;s what I wrote:</p>\n<pre>var _ = require(&#39;lodash&#39;);\n\nfunction Animal() {}\n\nAnimal.prototype.walk = function() {\nconsole.log(&quot;Hey there I&#39;m an Animal walking&quot;);\n};\n\nfunction Dog() {\nAnimal.call(this);\n}\n\n_.extend(Dog.prototype, Animal.prototype);</pre>\n<p>This is certainly how I would have solved the inheritance problem in any of my projects, but as it turns out this isn&#39;t the best solution in the context of someone evaluating your JS prowess. Firstly, my solution explicitly depends on <a href=\"https://lodash.com/\">Lo-Dash</a> (Underscore.js would also work just as well). These days it&#39;s hardly outlandish to assume that a given project would depend on either Lo-Dash or Underscore, so I don&#39;t see anything wrong with this but it still wasn&#39;t optimal in the given setting.</p>\n<p>Then there&#39;s the larger assumption my solution makes, which is that you&#39;re compiling your source through Browserify. Since I now use Browserify religiously on every project it didn&#39;t even occur to me to <span class=\"italic\">mention</span> this implicit dependency. If the interviewer wasn&#39;t familiar with Browserify himself he might have thought I was just crazy‚Äîrequiring modules in a browser üòï. Anyway, the answer they were going for was to use <code >Object.create</code> for defining the prototype of the subclass:</p>\n<pre>function Animal() {}\n\nAnimal.prototype.walk = function() {\nconsole.log(&quot;Hey there I&#39;m an Animal walking&quot;);\n};\n\nfunction Dog() {\nAnimal.call(this);\n}\n\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;</pre>\n<p>Both solutions accomplish the same thing, but the latter can simply be pasted into a browser console while the former would have to be run through Browserify and have Lo-Dash installed through NPM.</p>\n<h2>Back to the basics</h2>\n<p>What this brief experience made me realize is that there are still some basic JS methods that I&#39;m not familiar with. Of course now it&#39;s unlikely that I will forget <code >Object.create</code>. This was a very healthy realization, because despite the fact that I am unlikely ever to use <code >Object.create</code> in any project of my own it&#39;s still good to know the ins and outs of the language you write your software in.</p>\n<p>So, now that I&#39;m quite familiar with <code >Object.create</code> I&#39;m still going right back to my complex build process complete with browserify, stylus, jade and numerous Gulp tasks üòè. For anyone interested, my whole build process is implemented in a <a href=\"https://github.com/iansinnott/slush%E2%B8%BBexpress%E2%B8%BBisinn\">Slush generator I use for new Node projects</a>. The readme could use some work, but it should give you a gist of how I do my development.</p>","properties":{"tags":"javascript","created":"2015-01-09T00:00:00.000Z","title":"Back to the JavaScript Basics","disqusId":null}}},"pageContext":{"id":"d2c18ff2-b595-5f3f-80f9-e1fc3ff909dc","prev":{"id":"577d6e29-8c6a-51e6-a1be-25bcc76f7762","slug":"new-site-is-live","properties":{"title":"New Site Is Live","created":"2015-01-08T00:00:00.000Z"}}}}}